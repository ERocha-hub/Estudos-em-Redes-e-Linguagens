# Created 2026-02-25 qua 09:23
#+title: Structure and interpretation of computer programs(SICP)
#+author: Erik Ap Gomes Rocha
#+export_file_name: ~/Projetos/Codigos/Estudos-em-Redes-e-Linguagens/linguagens/notas_literarias_jaks.org
* Source

- =Author=: Hal Abelson, Jerry Sussman and Julie Sussman
- =Title=: Structure and interpretation of computer programs(SICP)
- =Year=: 1993
* Summary


* Capítulo 1 - Construindo abstrações com procedimentos

Vamos estudas a ideia de processos computacionais.
** 1.1.3 Avaliando combinações

Isso mostra como 2 coisas:
1. explicita a ordem das avaliações
2. mostra que é um processo naturalmente recursivo

Podemos escrever expressões aninhadas como:
#+begin_src scheme
(* (+ 2 (* 4 6))
   (+ 3 5 7))
#+end_src

em forma de árvore.

#+caption: Representação em árvore
[[file:ch1-Z-G-1.gif]]

E isso demonstra a importância da recursividade trabalhando com arvores hierárquicas.

Casos primitivos:
- valor de números são os números que eles nomeiam
- valor dos operadores built-in são as instruções sequências de máquina que correspendem com eles
- valor de outros nomes são os objetos associados a esses nomes no ambiente

Note que definições não são combinações e não estão descritas pelos princípios.

Exceções como essas são chamadas de formas especiais.
** 1.1.4 Procedimentos compostos

Podemos nomear a composição de procedimentos e chamá-la como se fosse uma unidade.
Exemplo:
#+begin_src scheme :session sicp :results none
(define (square x) (* x x))
#+end_src

Esta é a composição do procedimento (* x x) e de nomeá-lo de square.

Forma geral:
(define (<name> <formal parameters>) <body>)

- Separar as definições abaixo em uma lista

Onde:
"The <name> is a symbol to be associated with the procedure definition in
the environment.13 The <formal parameters> are the names used within
the body of the procedure to refer to the corresponding arguments of the
procedure. The <body> is an expression that will yield the value of the
procedure application when the formal parameters are replaced by the
actual arguments to which the procedure is applied.14 The <name> and
the <formal parameters> are grouped within parentheses, just as they
would be in an actual call to the procedure being defined.
"

#+begin_src scheme :session sicp :exports both
(square 21)
#+end_src

#+results: 
: 441


#+begin_src scheme :session sicp  :results none
(define (sum-of-squares x y)
  (+ (square x) (square y)))
#+end_src

#+begin_src scheme :session sicp :exports both
(sum-of-squares 3 4)
#+end_src

#+results: 
: 25


Agora podemos usar a =sum-of-squares= como bloco de construção de procedimentos.

#+begin_src scheme :session sicp :exports both :results value
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
(f 5)
#+end_src

#+results: 
: 136


Procedimentos compostos são usados da mesma forma que procedimentos primitivos, ou seja, não podemos diferenciá-los de =*= ou =+=.
** 1.1.5 O modelo de substiruição para aplicações de procedimentos

Os procedimentos de combinações compostas são substituidos e avaliados como se espera.

Sendo =f= definido como em 1.1.4:
#+begin_src scheme :exports code
(f 5)
#+end_src

será =f= substituido por:
#+begin_src scheme :exports code
(sum-of-squares (+ a 1) (* a 2))
#+end_src

Substituindo o valor de =a=5=:
#+begin_src scheme :exports code
(sum-of-squares (+ 5 1) (* 5 2))
#+end_src

Aplicando a definição de =sum-of-sqares=: 
#+begin_src scheme :exports code
(+ (square 6) (square 10))
#+end_src

Aplicando a definição de =square=:
#+begin_src scheme :exports code
(+ (* 6 6) (* 10 10))
#+end_src

Resuntando em:
#+begin_src scheme :exports code
(+ 36 100)
#+end_src

e
#+begin_src scheme :exports code
136
#+end_src

Este processo é chamado de =modelo de substiruição= para aplicação de procedimentos.

Obs:
- o modelo de substituição é uma questão didática. Na prática, o interpretador funciona de outra forma(cap 3-4).
- o modelo de substituição é um modelo simples, portanto, incompleto. Até o fim do livro, chegaremos em um modelo mais refinado e completo.
*** Ordem aplicativa vs ordem normal

No modelo mostrado, primeiro avaliamos o valor explicito das funções internas e, posteriormente, substituimos o procedimento. Outra forma de fazê-lo seria substiruir todos os procedimentos antes de avaliar os resultados, ou seja:

#+begin_src scheme :exports code
(f 5)
(sum-of-squares (+ 5 1) (* 5 2))
(+    (square (+ 5 1))      (square (* 5 2))  )
(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))
(+         (* 6 6)             (* 10 10))
(+           36                   100)
                    136
#+end_src

Isso dá a mesma resposta. Esse processo de "Expansão completa e então redução" é chamado de =avaliação de ordem-normal=, em contraste com "avaliação dos argumentos e depois aplicação" que é o metodo que o interpretador realmente usa, chamado =avaliação de ordem-aplicativa=.

Lisp usa =avaliação de ordem-aplicativa=, por otimizações como no caso da aplicação =(+ 5 1)= poder ser substituida por =6=, o que simplifica o processo de avaliação.
** 1.1.6 Expressões condicionais e Predicados

Até o momento não definimos procedimentos pra lidar com resultados diferentes a partir de testes(condicionais). Esse constructo é chamado de =análise de caso= que é uma forma especial.

No caso de Lisp, usamos =cond= como segue:
#+begin_src scheme :exports code :results none
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
#+end_src

Ou, de forma geral:
#+begin_src scheme :exposts code
(cond (<p1> <e1>)
      (<p2> <e2>)
...
      (<pn> <en>))
#+end_src

Consistindo do simbolo =cond= seguido por pares em parenteses (<p> <e>) chamados de cláusulas. <p> é um predicado, se seu valor for verdadeiro a expressão <e> é avalidada, se for falso, não.
- em scheme, falso é dados por =#f= e verdadeiro por qualquer outro valor, mas é conveniente usar =#t=.

Os predicados <p1>, <p2>, ... são avaliados em ordem até ser encontrado o primeiro valor verdadeiro.

=Predicado= é usado para procedimentos que dão resultado verdadeiro ou falso.

Outra forma de exprever a mesma expressão é:
#+begin_src scheme :exports code :results none
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
#+end_src

Ou:
=if= pode ser usado se existem precisamente 2 casos condicionais. Ou seja, =(if <predicate> <consequent> <alternative>)=.

Para construção dos predicados =<=, =>= e === é feita como constructos de predicados compostos com base nas funções:
- =(and <e1> ... <en>)= onde o valor da expressão é verdadeiro se todos os <e> forem verdadeiros e falso caso contrário.
  - As expressões são avaliadas da esquerda pra direita.
  - É uma forma especial pois nem todas expressões <e> precisam ser avaliadas.
- =(or <e1> ... <en>)= onde o valor da expressão é verdadeiro se algum dos <e> forem verdadeiros e falso caso contrário.
  - As expressões são avaliadas da esquerda pra direita.
  - É uma forma especial pois nem todas expressões <e> precisam ser avaliadas.
- =(not <e>)= inverte o valor lógico de <e>.
  - É um procedimento comum.
** Exercícios
*** Ex 1.1


#+begin_src scheme :tangle exercicios/ex11.scm
10
#+end_src

#+results: 
: 10


#+begin_src scheme :tangle exercicios/ex11.scm
(+ 5 3 4)
#+end_src

#+results: 
: 12


#+begin_src scheme :tangle exercicios/ex11.scm
(- 9 1)
#+end_src

#+results: 
: 8


#+begin_src scheme :tangle exercicios/ex11.scm
(/ 6 2)
#+end_src

#+results: 
: 3


#+begin_src scheme :tangle exercicios/ex11.scm
(+ (* 2 4) (- 4 6))
#+end_src

#+results: 
: 6


#+begin_src scheme :tangle exercicios/ex11.scm
(define a 3)
#+end_src

#+results: 
: #<unspecified>


#+begin_src scheme :tangle exercicios/ex11.scm
(define b (+ a 1))
#+end_src

#+results: 
: #<unspecified>


#+begin_src scheme :tangle exercicios/ex11.scm
(+ a b (* a b))
#+end_src

#+results: 
: 19


#+begin_src scheme :tangle exercicios/ex11.scm
(= a b)
#+end_src

#+results: 
: #f


#+begin_src scheme :tangle exercicios/ex11.scm
(if (and (> b a) (< b (* a b)))
    b
    a)
#+end_src

#+results: 
: 4


#+begin_src scheme :tangle exercicios/ex11.scm
(cond ((= a 4) 6)
      ((= b 4) (+ 6 7 a))
      (else 25))
#+end_src

#+results: 
: 16


#+begin_src scheme :tangle exercicios/ex11.scm
(+ 2 (if (> b a) b a))
#+end_src

#+results: 
: 6


#+begin_src scheme :tangle exercicios/ex11.scm
(* (cond ((> a b) a)
         ((< a b) b)
         (else -1))
   (+ a 1))
#+end_src

#+results: 
: 16
*** Ex 1.2

#+begin_src scheme :tangle exercicios/ex12.scm
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
#+end_src

#+results: 
: -37/150
*** Ex 1.3
#+begin_src scheme :tangle exercicios/ex13.scm :results none
(define (sum-of-squares x y)
;; alredy described
  (+ (* x x) (* y y)))

(define (sum-square-two-larger x y z)
  (if (and (< x y) (< x z))
      ;; if x is smaller sum-of-squares of others
      (sum-of-squares y z)
      (if (and (< y x) (< y z))
          ;; if y is smaller sum-of-squares of others
          (sum-of-squares x z)
          ;; if z is smaller sum-of-squares of others
          (sum-of-squares x y)))
  )
#+end_src

#+begin_src scheme :tangle exercicios/ex13.scm
(sum-square-two-larger 3 4 5)
#+end_src

#+results: 
: 41


#+begin_src scheme :tangle exercicios/ex13.scm
(sum-square-two-larger 4 3 5)
#+end_src

#+results: 
: 41


#+begin_src scheme :tangle exercicios/ex13.scm
(sum-square-two-larger 4 5 3)
#+end_src

#+results: 
: 41
*** Ex 1.4

#+begin_src scheme :tangle exercicios/ex14.scm :results none
(define (a-plus-abs-b a b)
  ((if (> b 0) + -) a b))
#+end_src

#+begin_src scheme :tangle exercicios/ex14.scm
(a-plus-abs-b 3 4)
#+end_src

#+results: 
: 7


#+begin_src scheme :tangle exercicios/ex14.scm
(a-plus-abs-b 3 -4)
#+end_src

#+results: 
: 7


#+begin_src scheme :tangle exercicios/ex14.scm
(a-plus-abs-b -3 4)
#+end_src

#+results: 
: 1
*** Ex 1.5

#+begin_src scheme :tangle exercicios/ex15.scm
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))
(test 0 (p))
#+end_src

#+results: 

Esse eu não consegui resulver.
- Voltar pra ver depois
